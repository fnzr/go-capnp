// Code generated by capnpc-go. DO NOT EDIT.

package lexer

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

type Token capnp.Struct
type Token_Which uint16

const (
	Token_Which_identifier        Token_Which = 0
	Token_Which_stringLiteral     Token_Which = 1
	Token_Which_binaryLiteral     Token_Which = 7
	Token_Which_integerLiteral    Token_Which = 2
	Token_Which_floatLiteral      Token_Which = 3
	Token_Which_operator          Token_Which = 4
	Token_Which_parenthesizedList Token_Which = 5
	Token_Which_bracketedList     Token_Which = 6
)

func (w Token_Which) String() string {
	const s = "identifierstringLiteralbinaryLiteralintegerLiteralfloatLiteraloperatorparenthesizedListbracketedList"
	switch w {
	case Token_Which_identifier:
		return s[0:10]
	case Token_Which_stringLiteral:
		return s[10:23]
	case Token_Which_binaryLiteral:
		return s[23:36]
	case Token_Which_integerLiteral:
		return s[36:50]
	case Token_Which_floatLiteral:
		return s[50:62]
	case Token_Which_operator:
		return s[62:70]
	case Token_Which_parenthesizedList:
		return s[70:87]
	case Token_Which_bracketedList:
		return s[87:100]

	}
	return "Token_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Token_TypeID is the unique identifier for the type Token.
const Token_TypeID = 0x91cc55cd57de5419

func NewToken(s *capnp.Segment) (Token, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Token(st), err
}

func NewRootToken(s *capnp.Segment) (Token, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1})
	return Token(st), err
}

func ReadRootToken(msg *capnp.Message) (Token, error) {
	root, err := msg.Root()
	return Token(root.Struct()), err
}

func (s Token) String() string {
	str, _ := text.Marshal(0x91cc55cd57de5419, capnp.Struct(s))
	return str
}

func (s Token) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Token) DecodeFromPtr(p capnp.Ptr) Token {
	return Token(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Token) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Token) Which() Token_Which {
	return Token_Which(capnp.Struct(s).Uint16(0))
}
func (s Token) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Token) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Token) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Token) Identifier() (string, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != identifier")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Token) HasIdentifier() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Token) IdentifierBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Token) SetIdentifier(v string) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetText(0, v)
}

func (s Token) StringLiteral() (string, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != stringLiteral")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Token) HasStringLiteral() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Token) StringLiteralBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Token) SetStringLiteral(v string) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetText(0, v)
}

func (s Token) BinaryLiteral() ([]byte, error) {
	if capnp.Struct(s).Uint16(0) != 7 {
		panic("Which() != binaryLiteral")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Token) HasBinaryLiteral() bool {
	if capnp.Struct(s).Uint16(0) != 7 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Token) SetBinaryLiteral(v []byte) error {
	capnp.Struct(s).SetUint16(0, 7)
	return capnp.Struct(s).SetData(0, v)
}

func (s Token) IntegerLiteral() uint64 {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != integerLiteral")
	}
	return capnp.Struct(s).Uint64(8)
}

func (s Token) SetIntegerLiteral(v uint64) {
	capnp.Struct(s).SetUint16(0, 2)
	capnp.Struct(s).SetUint64(8, v)
}

func (s Token) FloatLiteral() float64 {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != floatLiteral")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Token) SetFloatLiteral(v float64) {
	capnp.Struct(s).SetUint16(0, 3)
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Token) Operator() (string, error) {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != operator")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Token) HasOperator() bool {
	if capnp.Struct(s).Uint16(0) != 4 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Token) OperatorBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Token) SetOperator(v string) error {
	capnp.Struct(s).SetUint16(0, 4)
	return capnp.Struct(s).SetText(0, v)
}

func (s Token) ParenthesizedList() (capnp.PointerList, error) {
	if capnp.Struct(s).Uint16(0) != 5 {
		panic("Which() != parenthesizedList")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.PointerList(p.List()), err
}

func (s Token) HasParenthesizedList() bool {
	if capnp.Struct(s).Uint16(0) != 5 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Token) SetParenthesizedList(v capnp.PointerList) error {
	capnp.Struct(s).SetUint16(0, 5)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewParenthesizedList sets the parenthesizedList field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s Token) NewParenthesizedList(n int32) (capnp.PointerList, error) {
	capnp.Struct(s).SetUint16(0, 5)
	l, err := capnp.NewPointerList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Token) BracketedList() (capnp.PointerList, error) {
	if capnp.Struct(s).Uint16(0) != 6 {
		panic("Which() != bracketedList")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.PointerList(p.List()), err
}

func (s Token) HasBracketedList() bool {
	if capnp.Struct(s).Uint16(0) != 6 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Token) SetBracketedList(v capnp.PointerList) error {
	capnp.Struct(s).SetUint16(0, 6)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewBracketedList sets the bracketedList field to a newly
// allocated capnp.PointerList, preferring placement in s's segment.
func (s Token) NewBracketedList(n int32) (capnp.PointerList, error) {
	capnp.Struct(s).SetUint16(0, 6)
	l, err := capnp.NewPointerList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.PointerList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Token) StartByte() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Token) SetStartByte(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

func (s Token) EndByte() uint32 {
	return capnp.Struct(s).Uint32(16)
}

func (s Token) SetEndByte(v uint32) {
	capnp.Struct(s).SetUint32(16, v)
}

// Token_List is a list of Token.
type Token_List = capnp.StructList[Token]

// NewToken creates a new list of Token.
func NewToken_List(s *capnp.Segment, sz int32) (Token_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 1}, sz)
	return capnp.StructList[Token](l), err
}

// Token_Future is a wrapper for a Token promised by a client call.
type Token_Future struct{ *capnp.Future }

func (f Token_Future) Struct() (Token, error) {
	p, err := f.Future.Ptr()
	return Token(p.Struct()), err
}

type Statement capnp.Struct
type Statement_Which uint16

const (
	Statement_Which_line  Statement_Which = 0
	Statement_Which_block Statement_Which = 1
)

func (w Statement_Which) String() string {
	const s = "lineblock"
	switch w {
	case Statement_Which_line:
		return s[0:4]
	case Statement_Which_block:
		return s[4:9]

	}
	return "Statement_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Statement_TypeID is the unique identifier for the type Statement.
const Statement_TypeID = 0xc6725e678d60fa37

func NewStatement(s *capnp.Segment) (Statement, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return Statement(st), err
}

func NewRootStatement(s *capnp.Segment) (Statement, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return Statement(st), err
}

func ReadRootStatement(msg *capnp.Message) (Statement, error) {
	root, err := msg.Root()
	return Statement(root.Struct()), err
}

func (s Statement) String() string {
	str, _ := text.Marshal(0xc6725e678d60fa37, capnp.Struct(s))
	return str
}

func (s Statement) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Statement) DecodeFromPtr(p capnp.Ptr) Statement {
	return Statement(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Statement) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Statement) Which() Statement_Which {
	return Statement_Which(capnp.Struct(s).Uint16(0))
}
func (s Statement) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Statement) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Statement) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Statement) Tokens() (Token_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Token_List(p.List()), err
}

func (s Statement) HasTokens() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Statement) SetTokens(v Token_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewTokens sets the tokens field to a newly
// allocated Token_List, preferring placement in s's segment.
func (s Statement) NewTokens(n int32) (Token_List, error) {
	l, err := NewToken_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Token_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Statement) SetLine() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Statement) Block() (Statement_List, error) {
	if capnp.Struct(s).Uint16(0) != 1 {
		panic("Which() != block")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return Statement_List(p.List()), err
}

func (s Statement) HasBlock() bool {
	if capnp.Struct(s).Uint16(0) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s Statement) SetBlock(v Statement_List) error {
	capnp.Struct(s).SetUint16(0, 1)
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewBlock sets the block field to a newly
// allocated Statement_List, preferring placement in s's segment.
func (s Statement) NewBlock(n int32) (Statement_List, error) {
	capnp.Struct(s).SetUint16(0, 1)
	l, err := NewStatement_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Statement_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Statement) DocComment() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s Statement) HasDocComment() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Statement) DocCommentBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s Statement) SetDocComment(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s Statement) StartByte() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Statement) SetStartByte(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

func (s Statement) EndByte() uint32 {
	return capnp.Struct(s).Uint32(8)
}

func (s Statement) SetEndByte(v uint32) {
	capnp.Struct(s).SetUint32(8, v)
}

// Statement_List is a list of Statement.
type Statement_List = capnp.StructList[Statement]

// NewStatement creates a new list of Statement.
func NewStatement_List(s *capnp.Segment, sz int32) (Statement_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3}, sz)
	return capnp.StructList[Statement](l), err
}

// Statement_Future is a wrapper for a Statement promised by a client call.
type Statement_Future struct{ *capnp.Future }

func (f Statement_Future) Struct() (Statement, error) {
	p, err := f.Future.Ptr()
	return Statement(p.Struct()), err
}

type LexedTokens capnp.Struct

// LexedTokens_TypeID is the unique identifier for the type LexedTokens.
const LexedTokens_TypeID = 0x9e69a92512b19d18

func NewLexedTokens(s *capnp.Segment) (LexedTokens, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LexedTokens(st), err
}

func NewRootLexedTokens(s *capnp.Segment) (LexedTokens, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LexedTokens(st), err
}

func ReadRootLexedTokens(msg *capnp.Message) (LexedTokens, error) {
	root, err := msg.Root()
	return LexedTokens(root.Struct()), err
}

func (s LexedTokens) String() string {
	str, _ := text.Marshal(0x9e69a92512b19d18, capnp.Struct(s))
	return str
}

func (s LexedTokens) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LexedTokens) DecodeFromPtr(p capnp.Ptr) LexedTokens {
	return LexedTokens(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LexedTokens) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LexedTokens) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LexedTokens) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LexedTokens) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LexedTokens) Tokens() (Token_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Token_List(p.List()), err
}

func (s LexedTokens) HasTokens() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LexedTokens) SetTokens(v Token_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewTokens sets the tokens field to a newly
// allocated Token_List, preferring placement in s's segment.
func (s LexedTokens) NewTokens(n int32) (Token_List, error) {
	l, err := NewToken_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Token_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// LexedTokens_List is a list of LexedTokens.
type LexedTokens_List = capnp.StructList[LexedTokens]

// NewLexedTokens creates a new list of LexedTokens.
func NewLexedTokens_List(s *capnp.Segment, sz int32) (LexedTokens_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[LexedTokens](l), err
}

// LexedTokens_Future is a wrapper for a LexedTokens promised by a client call.
type LexedTokens_Future struct{ *capnp.Future }

func (f LexedTokens_Future) Struct() (LexedTokens, error) {
	p, err := f.Future.Ptr()
	return LexedTokens(p.Struct()), err
}

type LexedStatements capnp.Struct

// LexedStatements_TypeID is the unique identifier for the type LexedStatements.
const LexedStatements_TypeID = 0xa11f97b9d6c73dd4

func NewLexedStatements(s *capnp.Segment) (LexedStatements, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LexedStatements(st), err
}

func NewRootLexedStatements(s *capnp.Segment) (LexedStatements, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LexedStatements(st), err
}

func ReadRootLexedStatements(msg *capnp.Message) (LexedStatements, error) {
	root, err := msg.Root()
	return LexedStatements(root.Struct()), err
}

func (s LexedStatements) String() string {
	str, _ := text.Marshal(0xa11f97b9d6c73dd4, capnp.Struct(s))
	return str
}

func (s LexedStatements) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LexedStatements) DecodeFromPtr(p capnp.Ptr) LexedStatements {
	return LexedStatements(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LexedStatements) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LexedStatements) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LexedStatements) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LexedStatements) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LexedStatements) Statements() (Statement_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Statement_List(p.List()), err
}

func (s LexedStatements) HasStatements() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LexedStatements) SetStatements(v Statement_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewStatements sets the statements field to a newly
// allocated Statement_List, preferring placement in s's segment.
func (s LexedStatements) NewStatements(n int32) (Statement_List, error) {
	l, err := NewStatement_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Statement_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// LexedStatements_List is a list of LexedStatements.
type LexedStatements_List = capnp.StructList[LexedStatements]

// NewLexedStatements creates a new list of LexedStatements.
func NewLexedStatements_List(s *capnp.Segment, sz int32) (LexedStatements_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[LexedStatements](l), err
}

// LexedStatements_Future is a wrapper for a LexedStatements promised by a client call.
type LexedStatements_Future struct{ *capnp.Future }

func (f LexedStatements_Future) Struct() (LexedStatements, error) {
	p, err := f.Future.Ptr()
	return LexedStatements(p.Struct()), err
}

const schema_a73956d2621fc3ee = "x\xda\x84\x92\xcf\x8b\x1cE\x1c\xc5\xdf\xab\xea\xf9Ef" +
	"L\xda\xee\xc3\x06\x0c\xa3\x10a\x14\x11c\x02\xc1\x80\xac" +
	"L\xf0\xa0\x8c\x90JG\x03A%=3\x95\xb5\xdd\xd9" +
	"\x9e\xa1\xa7\xc0l@\xbc\x18\x88\x87@\x12\x02\"\xa8\x90" +
	"\x83h@\xc1\x88\x97\x1c<\xa8\xf1\xc7!\x81 *\x1e" +
	"\xc4\x83\x7f\x80g]uK\xbe\xbd:\xbb\xacY\xf64" +
	"\xd3\xef\xbdz\xf5\xad\xaa\xcf#7\xf8D\xb0\xaf\xf5\x8a" +
	"\x862\x9dJ\xd5\xef>\xf6\xcb\xf1[\xcf\xde\xbc\x08\xd3" +
	"\xa4\xf6\xbf}\xd9\xee\x7f\xf7\xdcc\xef\xe3I\xd6\xea@" +
	"t\x85\x97\xa2\xab\xac\x01\xfb\xdf\xe3A\x05\xfa\xb9w\xae" +
	"\xdd}\xff\xd5\xec]\x84M\xae\xa7+\x12\x89\x9e\x0a\xbe" +
	"\x88L \xff\x9e\x09\xe6A\xff\xfd\xe3\xdf\xfcx\xfd\xcd" +
	"\xf6\x95;e_\x0d~\x8d\xde(\xb3g\xcb\xec\xc1\x95" +
	"\x93\xe7\x17^,\xbe\x961\xd4\x861tM\x01\xd1\xf5" +
	"\xe0\x93\xe8sI\xef\xff,8N\x1c\xf6#{\xda\x16" +
	"\x0f\x0fRN\xf2\xc9\xa1c\xe3E\xcb\xfc\x08i::" +
	"hz\x1f\x10\x88\x1a<\x01$uj&1\x15[\\" +
	"\xf51\xc5\x08Y\x00\xc9.1\xee\xa1\xe2\x1e\xfd\xb7g" +
	"L\xd9e7\xcf\x00\xc9\x9c8{\xc5\x09\xfe\x12G\x03" +
	"\xd1}|\x19H\xee\x15\xe7!)\xab\xfc\xe9c\x06@" +
	"\xf4\x00\x9f\x06\x92\x8e\x18\x07\xc4\xa8\xae\xf8\x98\x15 \xda" +
	"\xc7K@r@\x8c\x93b\xd4\xfe\xf01\xab@\xf4B" +
	"\xb9\xfd\xf3b\x9c\xa3bXg\\^\xc8Y\x1e\x05\x92" +
	"\xd7E\xbf z#\x88)/p\x9e] 9'\xfa" +
	"e)R\xbf\xfb\x98\x0d \xbaX\x16]\x10\xe3m*" +
	"\xfalhs\x97\x9d\xca\xa0m\xc1&\x14\x9b\xa0\x9f\xba" +
	"\"\xcb\x17z\x19\xda\xce\x16\xe9h\xa6g\xb9\xb3\x0b\xb6" +
	"\xe8a>[3\x1aPl\x80\xfe\xd4h\x9c\xba^\xe6" +
	"\xb0\xb3\x94w@q\x07\xe8\xc7\x13[\xa4n\\\x00\x98" +
	"uL\xd2\xc2\xe6\xee%\xcbiv\xc6\x0e{\xd9\x94\x8e" +
	"w\x81G4\xff\xfb\xd9\xb5N\x17J\xd1\xf7\x8bt\xb0" +
	"h\x9dE[\x16l\x9f\x9f\xba\xb4p\xdde\x07Z\xd6" +
	"\xa1X\x07_\xb3\xf9\xb0\xbb\xecf\xdf\xbe\x9f\xe5i\xb1" +
	"\xbc~\xc6\x16\x14[\xe0\x8c\x11%\x8c\xf4\xeci;\x14" +
	"P\xf2)\x84\x94@\x07\x80\x80\x12\xb6\x0e\x01\xa6\xaei" +
	"\xf6*\xce\xbb2\xb1\xf5<\xff\xefL\\\xea\xec\x92\xad" +
	"\xe5n\xba\xa9\xf7\x04`\x9a\x9a\xa6\xa3\xcasH*\x87" +
	"v\x1b\xdag\xd0oj/\xa9\x96\xe2\xb6\xacq\xd2;" +
	"7\xeb}K\xe6\xbd\xaci>\x16\xaa\xfd\x1a\xd5\xe1G" +
	"\x0f\x02\xe6\x03M\xf3\xa9\xe2\x1e\xb5\xfa/\xd2\xe1\xb5G" +
	"\x01\xf3\xa1\xa6\xf9V1\xd4\xaa\xa49\xfcJ&\xbb\xa1" +
	"in+\x86\x01K\x92\xc3[G\x01sS\xd3\xfc\xa4" +
	"\x18VTIq\xf8C\x170\xb75\xcd\xcf\xdb\xdf\xcd" +
	"\xceQ\x96[T\xdb\xfd\xd1x\xb0\xb8\xf5\x19\x87\xe3\xc1" +
	"\xe1\xf1\xd2\x92\x85\xce\xdd\x06L\xb7}\xe6\x7f\x02\x00\x00" +
	"\xff\xff\xd9\xe9\x1d\x8b"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_a73956d2621fc3ee,
		Nodes: []uint64{
			0x91cc55cd57de5419,
			0x9e69a92512b19d18,
			0xa11f97b9d6c73dd4,
			0xc6725e678d60fa37,
		},
		Compressed: true,
	})
}
